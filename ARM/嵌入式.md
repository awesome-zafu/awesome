## 嵌入式复习资料整理
------------------------------------

TODOs should be fixed

--------------------
### 什么是嵌入式?
嵌入式系统是以应用为中心,以计算机技术为基础，以计算机技术为基础,软硬件可剪裁,适应应用系统,对功能.可靠性.成本.体积.功耗严格要求的专用计算机系统

### ARM体系结构的命名规则

| 后缀变量 |含义|
|---|---|
|x:|系列号，如ARM7，ARM9等|
|z:|Cache|
|D:|拥有JTAG调试器，支持片上Debug|
|I:|嵌入式ICE 支持片上断点和调试点|
|J:|Jazelle加速|
|S:|可综合版本|
|y:|存储管理/保护单元|
|T:|支持16位压缩指令集 Thumb|
|M:|内嵌硬件乘法器(Multiplier)|
|E:|增强指令(基于TDMI)|
|F:|向量浮点单元|


### 5级流水结构
> ARM9E从ARM7TDMI的**3级**流水线增加到了**5级**,ARM9E的流水线中容纳了更多的逻辑操作。

* 取址:从存储器中取出指令并将其放入指令流水线
* 译码:对取出的指令进行译码
* 执行:对每一个操作数移位，产生ALU的效果
* 缓冲:如果需要则访问数据存储器,否则ALU的结果只是简单地缓冲一个时钟周期,以便所有的指令具有相同的流水线流程
* 回写:将指令产生的结果回写到寄存器堆,包括从存储器取出的数据

### 哈佛结构和冯诺依曼结构
冯诺依曼结构具有共有的数据存储空间以及分离的访问总线。哈佛结构在指令执行时,取址和取数可以**并行**，因此具有更高的执行效率
> ARM9是哈佛结构 而ARM7的是冯诺依曼结构

### 经典ARM处理器系列主要参数

|项目|ARM7|ARM9|ARM10|ARM11|
|---|---|---|---|---|
|流水线深度|3级|5级|6级|8级|
|典型频率/MHz|80|150|260|335|
|功耗|0.06|0.19+(cache)|0.5+(cache)|0.4+(cache)|
|MIPS/MHz|0.97|1.1|1.3|1.2|
|架构|冯诺依曼|哈佛|哈佛|哈佛|
|乘法器|8*32|8*32|16*32|16*32|

### S5PV210处理器简介
> S5PV210采用了ARM CortexTM-A8 内核，ARM V7指令集 ，主频可达1GHz，64/32位内部总线结构，32/32KB的数据/指令一级缓存,512KB的耳机缓存,可以实现2000DMPS(每秒运算2亿条指令)的高性能运算能力。

### AMBA 
2.0版的AMBA(Advanced Microcontroller Bus Architecture)标准定义了三组总线:

* AHB(Advanced High-performance Bus)
* ASB(Advanced System Bus)
* APB(Advanced Peripheral Bus 外设总线)

### S5PV210存储区地址映射
|寄存器|地址|接口|
|---|---|---|
|特殊功能寄存器|0xE000_0000-0xFFFF_FFFF|SFRS|
|BOOT|0x0000_0000-0x1FFF_FFFF|IROM&IRAM Reserved|

### 时钟域

* MSYS(主系统)域的HCLK_MSYS.PCLK_MSYS(包括CPU使用的是ARMCLK)
* DSYS(显示系统)域的HCLK_DSYS.PCLK_DSYS
* PSYS(外围系统)域的HCLK_PSYS.PCLK_PSYS

### 高性能操作的频率值
> 建议值

* freq(ARMCLK)=1000MHz
* freq(HCLK_MSYS)=200MHz
* freq(HCLK_PSYS)=133MHz

### 电源管理方案的六种模式

* NORMAL模式:在NORMAL模式，CPU核心运行，即软件正在运行

* IDLE模式:在IDLE模式中,CPU核的时钟被关闭了,其余的部分运行

* DEEP-IDLE模式:这个模式下,CPU的核心电源是关闭的,即CPU核心电源供应,但要关闭内部电源开关。剩下的部分芯片保持相同的正常模式，或关闭电源(除了音频电源域的低功耗MP3播放应用)

* STOP模式:在这个模式下,S5PV210的时钟是关闭的(除了RTC模块)。因此,应用程序编程停止并等待唤醒事件恢复其操作。同时,CPU核心时钟是禁用的
> NOTICE:在正常模式下电源关闭的模块在停止模式下仍保持电源关闭状态

* DEEP-STOP模式: 在这个模式下,CPU核心和剩余部分的芯片电源都是关闭的(除了TOP,RTC和ALIVE模块),这个TOP模块可以关闭电源或打开电源。

* SLEEP 模块:在这个模式下,S5PV210使用调节器或电源管理集成电路从外部关闭内部电源(VDD_ARM,VDD_INT,VDD,PLL).因此S5PV210的内部电源是“关闭”的
> NOTICE:RTC电源和外部电源RTC I/O引脚仍然是“开启”的，如果唤醒事件发生时,通过唤醒复位初始化S5PV210，就像我们常说的上电复位一样。

### ARM处理器模式

|处理器模式|处理器模式描述|
|---|----|
|用户模式(User,usr)|正常程序执行的模式|
|快速中断模式(FIQ,fiq)|用于高速数据传输和通道处理|
|普通中断模式(IRQ,irq)|用于通常的中断处理|
|管理模式(Supervisor,svc)|供OS使用的一种保护模式|
|数据访问中止模式(Abort,abt)|用于虚拟存储及存储保护|
|未定义指令中止模式(Undefined,und)|用于支持通过软件仿真硬件的协处理器|
|系统模式(System,sys)|用于运行特权级的操作系统任务|

### ARM寄存器
> ARM一般共有**37**个寄存器

* 31个通用寄存器:包括程序寄存器(PC)在内 这些寄存器都是**32位**寄存器
* 6个状态寄存器:这些寄存器也是**32位**寄存器

### R14寄存器

> R14寄存器又被称为连接寄存器(Link Register,LR) 

特殊作用:

* 每一种处理器模式自己的物理R14中u存放当前子程序的返回地址,当通过跳转指令调用子程序时,R14被设置为该子程序的返回地址;在子程序中,把R14的值赋值到程序计数器PC中时 子程序返回

* 当异常中断发生时 该异常模式特定的物理R14被设置成该异常模式将要返回的地址 对于有些异常模式 R14的值可能与将返回的地址存在一个常数的偏移量。

### R15寄存器

程序计数器R15又被记为PC 当正确读取了PC的值时,该值为当前指令地址加**8字节**，对于ARM指令集来说,PC指向当前指令的下两条指令的地址。

### 当前状态寄存器(CPSR)

* 格式

||31    30|29  28|27  |   |8  7|6  5|4  0||
|---|---|---|---|---|---|---|---|---|
|N|Z|C|Q|Unused|I|F|T|Modes|

* 各个标志位的解释(I F T为低八位控制位)

|标志位|场景|为 1|为 0|
|---|---|---|---|
|N(Negative)|两个补码表示的有符号运算|运算结果<0|结果>=0|
|Z(Zero)|运算结果==0|结果！=0|
|C(Carry)|加法指令 |产生进位|不产生进位|
|V(Overflow)|加/减法指令,操作数和运算结果为二进制的补码表示的带符号数|符号位溢出|其他情况|
|I|普通中断禁止位|禁止IRQ中断||
|F|快速中断禁止位|禁止FIQ中断||
|T(Version>=ARMv4 && 属于T系列)|异常中断 开启特权模式|执行Thumb指令|执行ARM指令|
|T(Verson>=ARMv5 && 不属于T系列)|异常中断 开启特权模式|强制下一条执行的指令产生为定义指中断|执行ARM指令|

* CPSR的七种模式

//TODO:ADD Here

### 基址变址寻址
>  变址寻址通常用于访问某基址地址附近的地址单元

* 描述:

基址变址寻址就是将寄存器(基址寄存器)的内容与指令中给出的地址偏移量相加 从而得到一个操作数的有效地址   

* 举个栗子:
```	
	LDR R0,[R1,#0x0F]	;将寄存器R1的值加上0X0F作为地址,取出此地址中的数保存在寄存器R0中
	LDR R0,[R1],#4		;以i寄存器R1的内容作为操作数的有效地址,从而取得操作数存入寄存器R0中
	LDR R0,[R1,R2]		;将寄存器R1的内容加上寄存器R2的内容形成操作数的有效地址,从而取得操作数存入寄存器R0中
```
### 多寄存器寻址

* 描述:

一次可以传输几个寄存器的值;可以用一条指令来传输最多16个通用寄存器的值

* 举个栗子

```
	LDMIA 	R0,{R1,R2,R3,R4} 	;R1<-[R0],R2<-[R0+4];R3<-[R0+8];R4<-[R0+12]
	STMIA	R0,{R3-R5,R10}	;R0<-R3;[R0+4]<-R4;[R0+8]<-R5,[R0+12]<-R10
```

> 后缀IA表示每次执行完加载/存储操作后,R0按字长度自增

### 堆栈寻址

> 数据结构:FILO

* 举个栗子:

```
		STMFD	SP!,{R1-R7,LR}		;将寄存器R1-R7,LR的值入栈,堆栈满递减
		LDMFD	SP!,{R1-R7,LR}		;将数据出栈,放入寄存器R1-R7,LR 满递减堆栈

```

> 满递减(FULL Decending Stack):堆栈通过减少存储器的地址向下增长,堆栈指针指向内含有数据项的最低地址

### ARM指令集

* 条件码:

|操作码|条件助记符|判断标志|含义|
|---|---|---|---|
|0000|EQ|Z=1|相等|
|0001|NE|Z=0|不相等|
|0110|VS|V=1|溢出|
|1100|GT|Z=0,N=V|有符号数大于|

* 跳转指令:

	* B指令
		* 格式 :`B{条件} 目标地址`

		* 描述:跳转指令B限制在当前指令的+(-)32MB范围内

		* 栗子:
```
				B 	WAITA		;程序无条件跳转到标号WAITA处执行
				B 	0x1234		;跳转到绝对地址0x1234处

```

* 数据处理指令
		
	* ADC指令:

		* 格式:`ADC{条件}{S} 目的寄存器，操作数1,操作数2`

		* 描述:把两个数**相加**,再**加上CPSR中的C条件标志位**的值,将结果放到目的寄存器中,同时根据操作的结果**更新CPSR中相应的条件标志位**，它使用一个进位标志位,用于操作比**32位**大的数的加法,**注意不要忘记设置S后缀来更改进位标志**。

		* Remark:操作数1应是一个**寄存器**,操作数2可以是一个寄存器,被移位的寄存器,或一个立即数

		* 栗子:

				

					ADDS R0,R0,R2	;R0=R0+R2 进位  非进位为ADD
	
					ADC   R1,R1,R3	;使用ADC实现64位加法,(R1.R0)=(R1.R0)+(R3.R2)

				

	* BIC指令:

		* 格式:`BIC{条件}{S} 目的寄存器,操作数1,操作数2`

		* 描述:**清除操作数1的某些位**,并把结果放置到目的寄存器中,同时根据操作的结果**更新CPSR中相应的条件标志位**;操作数2为32位的**掩码**，如果在掩码中设置了某一位,则**清除**这一位,未设置的掩码位保持不变。

		* 栗子:
		
					BIC R0-,R0,#%1011	;清除R0中的位0,1和3  其他不变
					
					BIC R1,R1,#0x0F		;将R1的低四位(00001111)清零,其他位不变

					BIC R1,R2,R3	;将R3反码和R2相逻辑与,结果保存到R1

	* TST指令:
		
		* 格式:`TST{条件}操作数1,操作数2`

		* 描述: 把一个寄存器的内容和另一个寄存器的内容或立即数进行按位的与运算,并根据运算结果更新CPSR中条件标志位的值。操作数1 是 **要测试的数据**，操作数2是**个位掩码**,**该指令一般用来检测是否设置了特定的位**

		* 栗子:
	
					TST R0,#0x01		;判断R0的最低位是否为0
					TST R1,#0x0F		;判断R1的低四位是否为0

		> Remark:TST不保留运算结果,通常与EQ,NE条件配合使用,所有测试位为0时,EQ有效,而只要有一个测试不为0,则NE有效。

* 程序状态寄存器传输指令

	* MSR指令:

		* 格式:`MSR{条件} 程序状态寄存器(CPSR 或 SPSR) _<域> ,操作数`

		* 描述: 用于恢复状态寄存器的内容或者改变状态寄存器的内容
		
		* 域（32位）：

			* 位[31:24]为条件标志位域,用**f**表示
			* [23:16]:状态位域,用**s**表示
			* [15:8]：扩展位域,用**x**表示
			* [7:0]:控制位域,用**c**表示

		* 栗子:

					MSR CPSR_c,#0xD3		;CPSR[7...0]=0xD3 ,即切换到管理模式
					MSR CPSR_cxsf,R3		;CPSR=R3


	* LDM/STM指令:

		* 描述:用于现场保护,数据复制,参数传输等
		
		* 8种模式(前4种用于**数据块传输**,后4种是**堆栈操作**):
			
			* IA:每次传输**后**地址**加**4.
			* IB:每次传输**前**地址**加**4.
			* DA:每次传输**后**地址**减**4.
			* DB:每次传输**前**地址**减**4.
			* FD:**满递减**堆栈
			* ED：**空递增**堆栈
			* FA:**满递增**堆栈
			* EA:**空递增**堆栈

### ARM伪指令
* 大范围地址读取---LDR伪指令

	* 格式: `LDR{条件} 目的寄存器,=表达式`

		* 表达式可以不存 **机器指令** 而 放入 **文字池**,不受**12位**立即数的限制,文字池可以表示**4字节**的任意整型数

		* 当`LDR`被替换为`LDR+文字池`时,由于LDR指令的第二个操作数为**12位**	所以从指令位置到文字池的偏移量必须小于12位可以表示的范围,即`4KB`(2^12)
	
		* 与ARM的LDR相比 伪指令的LDR参数有"="号,而不是"#"号

		`LDR{条件} 目的寄存器,=常数`

		> 当要给超过12位的立即数进行赋值操作时 可以使用`LDR`来完成（去掉# 换成，=）

		`LDR{条件} 目的寄存器,=地址标号`

		> 当跳转范围超过`32MB时  我们可以使用`LDR`  然而 	`LDR`为绝对地址寻址 所以要确保**加载地址**和**运行地址**一样

	* 描述:用于加载32位的立即数或一个地址值到指定寄存器。`LDR`伪指令被编译器替换成一条合适的指令。如果 加载的常数未超过`MOV`或 `MVN`用12位立即数表示的范围，则使用`MOV` `MVN`指令代替该`LDR`指令 否则 汇编器将常量文字池 并使用一条程序**相对偏移**的`LDR`指令从文字池读出常量。

### 伪操作与宏

* 符号定义伪操作之GBLA && GBLL && GBLS

	* 描述: 

		* GBLA伪操作用于定义全局的数字变量	并初始化为0

		* GBLL伪操作用于定义全局的逻辑变量	并初始化为FALSE
	
		* GBLS伪操作作用于定义一个全局的字符串变量	并初始化为空值

	* 栗子:

				GBLA	object		;定义一个全局的数字变量	变量名为object
				object	SETA	oxff	;将变量初始化为0xff
				GBLL	codebg	;定义一个全局的逻辑变量	变量名为codebg
				codebg	SETL	{TRUE}	; 将变量名赋值为真
				GBLS	codech		;定义一个全局字符串 变量名为codech
				codech	SETS	“FUCK”	;赋值操作

		> 重新声明的场景:值为**后一次**声明的值;
		   作用范围(生命周期):**包含该变量的源程序**;

* 数据定义伪操作之DCD和DCDU伪操作

	* 格式: `标号	DCD(DCDU)	表达式`

	* 描述:`DCD`分配一段字内存单元	并用伪操作中指定的表达式初始化,内存**需要**字对齐,一般用于定义数据表格或是其他常数	`DCDU`功能与`DCD`差不多 但是它**不需要**字对齐

	* 栗子:

				DateTest	DCD	4,5,6	分配一片连续的字存储单元并初始化

* 杂项伪操作

	* EXPORT 和 GLOBAL 伪操作
		
		* 格式:`EXPORT	标号	{[WEAK]}`

		* 描述：`EXPORT`伪操作用于在程序中声明一个**全局**的标号	该标号可在其他的文件中引用	`EXPORT`可用`GLOBAL`代替

		* 栗子:

					EXPORT	InitStack	;声明一个可全局引用的标号
					GLOBAL	Vectors	;声明一个可全局引用的标号

		> 所以  这段应该要说的是 	`EXPORT`可用`GLOBAL`代替

	* IMPORT和EXTERN伪操作

		* 格式:`IMPORT(或EXPORT)	标号{[WEAK]}`

		* 描述:`IMPORT`与`EXTERN`都用于引用其他源文件	但是`IMPORT`中的引用不管是否实际用到都会加入到当前源文件的符号表中	而用`EXTERN`  若实际没有引用到 则不会被加入到当前源文件的符号表中

		* 栗子：

					AREA	Init,CODE,READONLY
					IMPORT	(EXTERN)	Main	;引用其他源文件的声明
					...
					END

	* INCLUDE/GET伪操作

		* 格式:`GET	文件名`

		* 描述: GET 伪操作用于将一个**源文件**包含到当前的源文件中，并将被包含的源文件**在当前位置进行汇编处理**。**可以使用 INCLUDE 代替 GET**。可以使用路径信息（路径信息中可以包含空格）。汇编程序中常用的方法是在某源文件中定义一些宏指令，用 EQU 定义常量的符号名称，用 MAP和 FIELD 定义结构化的数据类型，这样的源文件类似于C语言中的.H文件。然后用 GET 伪操作将这个源文件包含到其他的源文件中。使用方法与 C 语言中的 “ include *.h” 相似。 

		* 栗子：

					INCLUDE	fuck.s	;当前源文件 包含并编译 fuck.s

	* INCBIN伪操作

		* 格式:`INCBIN	文件名`

		* 描述: 其他同**GET** 但是INCBIN不会在当前源文件下编译	而是原封不动地放在当前文件中。

		* 栗子：

					INCBIN	fuck.bat	;当前源文件 包含 fuck.bat
	
* ARM编程实例:
		
> TODO:**见书P63**  	有时间再码~


### ATPCS(ARM-Thumb Produce Call Standard)

* ATPCS中的各寄存器使用规则

|寄存器|别名|特殊名|使用规则|
|---|---|---|---|
|R0|A0||参数寄存器1|
|R1|A1||参数寄存器2|
|R2|A2||参数寄存器3|
|R3|A3||参数寄存器4|
|R4|V1||ARM状态局部变量寄存器1|
|R5|V2||ARM状态局部变量寄存器2|
|R6|V3||ARM状态局部变量寄存器3|
|R7|V4|WR|ARM状态局部变量寄存器4 Thumb状态工作寄存器|
|R8|V5||ARM状态局部变量寄存器5|
|R9|V6|SB|ARM状态局部变量寄存器6  在支持RWPI的ATPCS中为静态基址寄存器|
|R10|V7|SL|ARM状态局部变量寄存器3  在支持数据栈检查的ATPCS中为数据栈限制指针|
|R11|V8|FP|ARM状态局部变量寄存器8/帧指针|
|R12|--|IP|子程序内部调用的scratch寄存器|
|R13|--|SP|数据栈指针|
|R14|--|LR|链接寄存器|
|R15|--|PC|程序计数器|

> R0-R3负责传递参数	被调用的子程序在返回前无须恢复寄存器R0-R3的内容
> R4-R11保存全局变量	子程序进入时必须保存这些寄存器的值，在返回时必须恢复这些寄存器的值。没有用到的则不用恢复。**在Thumb程序中,通常只能使用寄存器R4-R7来保存局部变量**
> **scratch寄存器**:用于保存SP 在函数返回时使用该寄存器出栈

* ATPCS中的数据栈
	
	* 数据栈栈指针(Stack Pointer):指向最后一个写入栈的数据的内存地址

	* 数据栈的基地址(Stack Base):数据栈的最高地址。由于ATPCS中的数据栈是FD类型的,实际上数据栈中最早入栈数据占据的内存单元是基地址的下一个内存单元地址。

	* 数据栈界限(Stack Line)：数据栈中可以使用的最低的内存单元地址

	* 已占用的数据栈(Used Stack)：数据的基地址和数据栈栈指针之间的区域	其中包括数据栈栈指针对应的内存单元	但不包括基地址对应的内存单元

	* 未占用的数据栈(Unused Stack)：数据栈指针 和 数据栈界限之间的区域，其中包括数据栈界限对应的内存单元	 但不包括数据栈栈指针对应的内存单元

	* 数据栈中的数据帧(Stack Frames):在数据栈中,为子程序分配的用来保存寄存器和局部变量的区域。

* 内嵌汇编指令下的物理寄存器
	
	> 限制:不能直接向PC寄存器中赋值,程序的跳转只能通过**B指令**和**BL指令**实现

* 内嵌汇编指令注意事项

	* 不要使用寄存器代替变量
	> 尽管有时寄存器明显对应某个变量 但也不能直接使用寄存器代替变量

```
		int bad_f(int x){		//x 存放于R0中
				__asm{
			ADD R0,R0,#1	//发生寄存器冲突	实际上R0并没有变化
		}
			return x;
		}	
```
> 正确写法 :

```
int bad_f(int x){
		__asm{
			ADD x,x,#1
		}
	return x;
	}
```

*	汇编调用C程序

	*	栗子:

```
		//C程序
	int g(int a,int b,int c,int d,int e){
		return	a+b+c+d+e;
	}
	//汇编程序
	EXPORT	f
	AREA f,CODE,READONLY	
	IMPORT 	g			//Hook Function  g()
	STR	LR,[SP,#-4]	//保存返回地址
	ADD	R1,R0,R0	//R0<-i	R1<-2*i
	ADD	R2,R1,R0	//R2<-3*i
	ADD	R3,R1,R2	//R3<-5*i
	STR	R3,[SP,#-4]	//第5个参数通过数据栈传递,压入堆栈
	ADD	R3,R1,R1	//计算第4个参数为 4*i
	BL		g			//call g()
	ADD	SP,SP,#4	//调用数据栈指针,准备返回
	LDR	PC,[SP],#4	//返回
	END
```

### GPIO

>	GPIO是ARM芯片最基本的IO通道，在RVDS下操作类似于单片机,直接读写寄存器。S5PV210共有**237**个GPIO端口 ，分为**15**组。

*	各组GPIO数量及属性如下:
	
	*	GPA0：8	I/O引脚
	*	GPA1：4	I/O引脚
	*	GPB:	8	I/O引脚
	*	GPC0:	5	I/O引脚
	*	GPC1：5	I/O引脚
	*	GPD0：4	I/O引脚
	*	GPD1：6	I/O引脚

*	I/O操作步骤:

	1. 确定控制过程中用到GPIO端口的功能;如果只是作为基本I/O引脚来进行控制，则大部分情况下不需要进行GPIO上拉/下拉寄存器的位置，如果需要使用引脚的其他功能，则需对照S5PV210的芯片手册对应位进行设定

	2. 要进行引脚I/O方向控制	通过**端口控制寄存器**进行相应设置，完成端口为I/O或者第二功能引脚的设置（0000表示输入，0001表示输出）

	3. 对数据寄存器进行操作完成I/O功能的实现，如果设置为输入引擎，则通过读取数据寄存器就能实现引脚状态的读取，反之，设置为输出引脚，则通过写数据寄存器就能实现引脚状态的设置。

*	GPH0CON 寄存器位的设置

|GPH0CON|位|描述|初始状态|
|---|---|---|---|
|GPH0CON[0]|[3:0]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[0]|0000|
|GPH0CON[1]|[7:4]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[1]|0000|
|GPH0CON[2]|[11:8]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[2]|0000|
|GPH0CON[3]|[15:12]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[3]|0000|
|GPH0CON[4]|[19:16]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[4]|0000|
|GPH0CON[5]|[23:20]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[5]|0000|
|GPH0CON[6]|[27:24]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[6]|0000|
|GPH0CON[7]|[31:28]|0000-输入;0001-输出;0010～1110--保留;1111-EXT_INT[7]|0000|

*	GPC1CON寄存器

|GPC1CON|位|描述|初始状态|
|---|---|---|---|
|GPC1CON[4]|[19:16]|0000-输入;0001-输出;0010-PCM_2_SOUT;0010-保留;0010-12S_2_SDO;0101～1110 保留 1111-GPC1_INT[4]|0000|
|GPC1CON[3]|[15:12]|0000-输入;0001-输出;0010-PCM_2_SIN;0011保留;0100-12S_2_SDI;0101～1110 保留 1111-GPC1_INT[3]|0000|
|GPC1CON[2]|[11:8]|0000-输入;0001-输出;0010-PCM_2_FSYNC;0100-LCD_FRM;0010-12S_2_LRCK;0101～1110 保留 1111-GPC1_INT[2]|0000|
|GPC1CON[1]|[7:4]|0000-输入;0001-输出;0010-PCM_2_EXTCLK;0011-SPDIF_EXTCLK;0010-12S_2_CDCLK;0101～1110 保留 1111-GPC1_INT[1]|0000|
|GPC1CON[0]|[3:0]|0000-输入;0001-输出;0010-PCM_2_SCLK;0011-SPDIF_0_OUT;0100-12S_2_SCLK;0101～1110 保留 1111-GPC1_INT[0]|0000|

* Makefile 写法

	* 栗子:
		
```
key.bin:start.o key.o
	arm-linux-ld	-Ttext 0x20000000	-o	key.elf	$^
	arm-linuc-objcopy	-o	binary	key.elf	$@
	arm-linux-objdump	-D	key.elf	>	key.dis
key.o	:	key.c
	arm-linuc-gcc	-c	$<	-o	$@
start.o:start.S
	arm-linux-gcc	-c	$<	-o	$@
clean:
	rm	*.o *.elf *.bin	*.dis
```

###	存储器

*	RAM

>	RAM分为 静态存储器(Static RAM ,SRAM)和动存储器(Dynamic RAM.DRAM),

*	DRAM与SRAM

|RAM存储器|访问速度|功耗|价格|应用|
|---|---|---|---|---|
|SRAM|快|较高|高|高速缓存存储器|
|DRAM|较慢|低|低|主存 帧缓冲区|

> 通常人们说的SDRAM(Synchromous DRAM)是DRAM的一种  是同步动态随机存取储存器

*	存储器控制寄存器 MEMCONTROL

	*	参数配置

	|MEMCONTROL|位|描述|R/W|初始状态|
	|---|---|---|---|---|
	|num_chip|[19:16]|内存芯片参数:0x0---1 ; 0x1---2 0x2~0xf---保留|R/W|0x0|
	|mem_width|[15:12]|内存数据总线宽度:0x0--保留 ; 0x1--16bit; 0x2--32bit; 0x3~0xf--保留|R/W|0x2|
	|mem_type|[11:8]|存储类型:0x0--保留;0x1---LPDDR;0x2--LPDDR2;0x3--保留;0x4--DDR2;0x5~0xf--保留|R/W|0x1|

*	存储器配置寄存器(MEMCONFIG0/1)

	*	参数配置（**高8位**）

	|MEMCONFIG0|位|描述|R/W|初始状态|
	|---|---|---|---|---|
	|chip_base|[31:24]|AXI基地址:AXI base address [31:24]--chip_base.举个栗子，如果chip_base=0x20,则芯片0的存储AXI基地址变为0x2000_0000|R/W|DMC0:0x20 DMC1:0x40|
	|chip_mask|[23:16]|栗子:如果chip_mask=0xF8 那么AXI偏移地址变为0x0000_0000~0x07FF_FFFF 如果chip0的存储AXI基地址是0x0000_0000，那么chip0的存储地址在0x2000_0000~0x27FF_FFFF|R/W|DMC0:0xF0  DMC1:0xE0|

### 中断向量

>	当中断源发出的中断信号被CPU检测到之后,如果芯片的中断控制系统允许响应这个中断,那么中断就会跳转到一个固定的地址空间执行	而这个固定的地址就是**中断入口地址**	也就是**中断向量**	这个地址由ARM内部硬件决定。

>	每个中断源都有各自的中断向量	这些向量一般在程序存储空间中占用一个连续的地址空间段,称为中断向量区。

###	S5PV210的中断源
>	分为**4组**	每组包含**32个**中断源	共支持**128个中断源**

*	中断控制器支持的中断源

|模块|VIC Port No.|No.|INT请求|注释|
|---|---|---|---|---|
|VIC0 System DMA Timer|25|25|TIMER4||
|VIC0 System DMA Timer|24|24|TIMER3||
|VIC0 System DMA Timer|23|23|TIMER2||
|VIC0 System DMA Timer|22|22|TIMER1||
|VIC0 System DMA Timer|21|21|TIMER0||
|VIC0 System DMA Timer|20|20|PDMA1||
|VIC0 System DMA Timer|15|15|EINT15|EXT_INT[15]|
|VIC0 System DMA Timer|14|14|EINT14|EXT_INT[14]|
|VIC0 System DMA Timer|13|13|EINT13|EXT_INT[13]|
|VIC0 System DMA Timer|12|12|EINT12|EXT_INT[12]|
|VIC0 System DMA Timer|11|11|EINT11|EXT_INT[11]|
|VIC0 System DMA Timer|10|10|EINT10|EXT_INT[10]|
|VIC0 System DMA Timer|9|9|EINT15|EXT_INT[9]|
|VIC0 System DMA Timer|8|8|EINT8|EXT_INT[8]|
|VIC0 System DMA Timer|7|7|EINT7|EXT_INT[7]|
|VIC0 System DMA Timer|6|6|EINT6|EXT_INT[6]|
|VIC0 System DMA Timer|5|5|EINT5|EXT_INT[5]|
|VIC0 System DMA Timer|4|4|EINT4|EXT_INT[4]|
|VIC0 System DMA Timer|3|3|EINT3|EXT_INT[3]|
|VIC0 System DMA Timer|2|2|EINT2|EXT_INT[2]|
|VIC0 System DMA Timer|1|1|EINT15|EXT_INT[1]|
|VIC0 System DMA Timer|0|0|EINT0|EXT_INT[0]|

*	中断状态寄存器

>	每一个中断源对应状态寄存器中的一位 共32位([31:0])位 如果某一位为0,代表相应中断源无效;为1,相应中断源可用。


*	中断选择寄存器(VIC0INTSELECT)

>	所有中断源在中断请求时都要确定使用哪一种中断模式,VICINTSELECT寄存器可以选择中断源的中断类型,与程序状态寄存器相同，该寄存器的每一位对应一个中断源,共**32**位

|VICINTSELECT|位|描述|初始状态|
|---|---|---|---|
|IntSelect|[31:0]|选择中断中断请求类型的寄存器,0-IRQ 中断;1-FIQ 中断 ,寄存器中每一位对应一个中断源|0x00000000|

*	GPIO中断挂起寄存器(GPA0_INT_PEND)

>	用来指示对应的中断是否被激活 当中断被发生	相应位为1 ;反之， 相应位为0。

*	GPIO中断屏蔽寄存器(GPA0_INT_MASK)

>	当该寄存器的相应位1时,对应的中断就会被禁止;当相应位为0时,对应中断被允许。除了**保留位**外,其他各位初始位均为1。

*	中断服务程序需要进行的步骤

	*  进入中端服务程序后 首先屏蔽中断 防止其他中断干扰该中断服务程序的执行

	*	执行编写的中断服务程序的主要功能语句 完成对中断的影响操作

	*	清除中断挂起寄存器(GPA0_INT_PEND)中相应的位
	
	*	清除中断向量寄存器(VICxVECTADDR)中相应的位

	*	取消中断的屏蔽，等待新中断的产生

	*	结束服务程序,返回。

>	中断服务程序即是中断申请产生后 如果中断被允许	系统转去执行的处理函数

*	栗子:

```
				//设置精确度为1s
				rTCNTB0=1000000;
				rTCON|=1|(1<<1)|(1<<3);	//设置自动加载使能,手动更新使能，Time0启动
				rTCON&=~2;			//关闭手动更新 执行递减的寄存器是TCNT
```		

### 串口通信

*	波特率:

>	这是一个衡量通信速度的参数 表示每秒传输的位的个数;波特率和距离成反比

*	数据位:

>	衡量通信中实际数据位的参数  **包**的概念:每个包是指**一个字节** 包括**开始/停止**位 **数据位** 和 **奇偶校验**位

*	停止位:

>	用于表示单个包的最后一位。典型值为1,1.5和2位

*	奇偶校验位:

>	在串口通信中一种简单的检错方式。有四种检错方式:偶.奇.高和低。当然没有校验位也是可以的。

###	通用异步接收器和发送器(UART)

>	UART0支持**接收/发送独立的256字节FIFO**	UART1支持**64B**的FIFO,UART2/3均可支持**16B**的FIFO。

*	UART行控制寄存器(ULCONn)

	*	设置:

	|ULCONn|位|描述|初始状态|
	|---|---|---|---|
	|Infrared Mode|[6]|决定是否使用红外模式;0-正常模式操作;1-红外接收发送模式|0|
	|Parity Mode|[5:3]|在UART发送接收操作中定义奇偶码的生成和检验类型|000|
	|Number of Stop Bit|[2]|定义多少个停止位用于帧末信号;0-一个停止位/帧,1-两个停止位/帧|0|
	|Word Length|[1:0]|指出发送接收每帧的数据位数00-5 bit 01-6 bit 10-7 bit 11-8 bit|00|

*	UART控制寄存器

|UCONn|位|描述|初始位|
|---|---|---|---|
|时钟源选择|[10]|选择PCLK或SCLK_UART(来自于时钟控制器)时钟产生UART波特率|0|
|发送模式|[3:2]|决定使用哪种方式发送数据 00-禁用 01-中断请求或是轮询模式 10-DMA模式 11-保留|00|
|接受模式|[1:0]|决定使用哪种方式接收数据 设置同发送模式|00|

###	UART操作寄存器

>	UTRSTATn寄存器用于记录UART发送和接收的状态
			
|UTRSTATn|位|描述|初始状态|
|---|---|---|---|
|Transmitter empty|[2]|如果缓冲器没有有效数据传输  传输和发送移位寄存器是空的|0|
|Receive buffer data ready|[0]|如果接收缓冲寄存器包含有效数据,接收到RXDn端口 此位自动设置为1|0|

*	GPA0引脚


|GPA0CON[1]|[7:4]|0000 输入 0001 输出 0010 UART_0_TXD 0011-1110 保留  1111 GPA0_INT[1]|0000|
|---|---|---|---|
|GPA0CON[1]|[3:0]|0000 输入 0001 输出 0010 UART_0_RXD 0011-1110 保留  1111 GPA0_INT[0]|0000|

*	栗子:
> 书P155  大段代码

*	功能函数:

	*	发送函数:
			
				void uart_send_byte(unsigned char byte){
						while(!(UTRSTAT0&(1<<2)));	/*等待发送缓冲区为空*/
						UTXH0=byte;	/*发送一字节数据*/
				}
				void uart_send_string(char* str){
					Char *p=str;
					while(*p){
						uart_send_byte(*p++);
					}
				}
> 在想发送缓冲器中写入数据之前要查询发送,接收缓冲状态寄存器，确定发送缓冲器是否为空。

	*	接收函数:

			unsigned char uart_recv_byte(){
				while(!(UTRSTATO &1));		//等待接收缓冲区有数据可读
				return URXH0;					//接收一字节数据
			}


> 接收的时候要确定接收缓冲寄存器是否有数据 有数据才执行 否则一直阻塞

### 触摸屏的主要类型

* 电阻式

* 电容式 

* 红外线式

* 表面声波式

###	S5PV210的ADC与触摸屏

*	分辨率为10位/12位(可选)

###	触摸屏接口模式

*	分离的X,Y坐标转换模式

>	包含两种状态,X坐标测量状态 和 Y坐标测量状态。

X坐标测量状态时  **TSCONn**的值设为**0x69**
Y坐标测量状态时  **TSCONn**的值设为**0x9a**

*	连续X,Y坐标转换模式

连续X,Y坐标转换模式时  **TSCONn**的值设为**0x5c**

*	等待中断转换模式

等待中断转换模式时  **TSCON[7:0]**的值设为**0xd3**

###	ADC和触摸屏接口特殊寄存器

*	ADC控制寄存器TSADCCON0

TSADCCON0是一个可读写的寄存器 地址为0xE170_0000 复位值为0x0000_3FC4。在这个寄存器中 可以选择接入的触摸屏(0/1) 或是设定转换值位数(10/12位)

*	ADC触摸屏控制寄存器 TSCON0

这个寄存器也可以进行读写	地址为0xE170_0004,复位值为0x0000_0058 

>	当等待触摸屏中断时,XP_SEN位(XP输出无效)应该置1 且 PULL_UP(XP上拉使能)位应该置0
>	仅在自动连续X,Y坐标转换中 AUTO_PST位应该置1

### 触摸屏实例:

```
//初始化ADC函数
void adc_init(){

	TSADCCON0|=1<<17;
	TSADCCON1=1<<14|19<<6|0<<2;		//3.3MHz
	TSDLY=0xffff;
	TSCON1=0xd3;
	uart_send_string("\rfunced ok\n");
}
```

```
//坐标转换函数  逻辑函数
void key_handle(){
	uart_send_string("test");
//清空向量寄存器
	VIC2ADDRESS=0;
	VIC3ADDRESS=0;

	VIC3VECTADDR0=0xFFFFFFFF;
	VIC3VECTADDR1=0xFFFFFFFF;
//设置x,y为自动转换
	TSCON1=0xdc;
	TSADCCON1|=1;
//开始转换
	while(TSADCCON1 & 0x1);	
//判断是否结束转换
	while(!(TSADCCON1 & (1<<15)));
	uart_send_string("\rX:");
	uart_send_num(TSDATX1 & 0x3ff);
	uart_send_string(" Y:");
	uart_send_num(TSDATX1 & 0x3ff);
	uart_send_byte('\n');
	TSCON1=0xd3;
}
```

> 书P162写成'0'+的作用:uart_send_byte(char v)的参数为一个char类型参数,通过加上ASCII值为48的'0' **把int型的数字转化为对应的字符类型的数字**